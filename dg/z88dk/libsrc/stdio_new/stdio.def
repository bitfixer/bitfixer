

; ****************************
; FORMATTED OUTPUT BUFFER SIZE
; ****************************
;
; A buffer of size STDIO_TEMPBUFSIZE bytes is allocated on the stack to construct
; numbers and various strings to be output on the output stream at the FILE* level.
;
; This buffer must be large enough to hold the maximum requirements of the various
; output specifiers %d, %x, etc.

defc STDIO_MAXPRECISION = 32                       ; maximum precision for numbers on output stream
defc STDIO_TEMPBUFSIZE  = STDIO_MAXPRECISION + 3   ; size of temp buffer allocated on stack for output stream

; ****************************
; MAXIMUM NUMBER OF OPEN FILES
; ****************************
;
; These determine the size of file tables maintained and represent a hard limit
; on the maximum number of simultaneously open files.  Since this library allocates
; memory for file structures using malloc, which may include additional bytes requested
; by a driver, fewer than the maximum number of files may be simultaneously opened
; than indicated here due to memory constraints.

defc STDIO_NUMFD   = 11        ; maximum number of open fds
defc STDIO_NUMFILE = 8         ; maximum number of open FILEs, not including stdin / stdout / stderr

; **************
; STDIO MESSAGES
; **************
;
; These messages and associated parameters are generated by the stdio library and are
; passed through the stdio chain to the various buffer drivers, filter drivers and
; device drivers making up the chain.
;
; These messages are separated into distinct groups including fundamental stdio messages,
; socket messages and file system messages.  This is to help the drivers in the stdio chain
; quickly determine which messages can safely be ignored.  Drivers are expected to interpret
; messages by table lookup for the relevant function address to deal with a specific message.
; The most common messages (such as GETC and PUTC) should be dealt with using specific compare
; instructions prior to table lookup in order to speed up the library.
;
; message id passed in A register
; called function must preserve ix and exx registers

; FUNDAMENTAL MESSAGES

defc STDIO_MSG_PUTC        = 0   ; enter: c = char, exit: carry set = error
defc STDIO_MSG_GETC        = 1   ; exit: a = char, carry set = error
defc STDIO_MSG_FERR        = 2   ; exit: a = error flags (bit 7 = EOF)
defc STDIO_MSG_WRIT        = 3   ; enter: de = src buffer hl = size!=0, exit: hl = number of bytes transferred (0, carry set = error)
defc STDIO_MSG_READ        = 4   ; enter: de = dst buffer hl = size!=0, exit: hl = number of bytes transferred (0, carry set = error)
defc STDIO_MSG_SEEK        = 5   ; enter: dehl = file pos c = STDIO_SEEK_*, exit: dehl = new file pos or carry set = error

defc STDIO_MSG_GROUP_0     = 6   ; all drivers likely have to implement the messages above

defc STDIO_MSG_POLL        = 6   ; enter: c = events, exit: c = revents or carry set = unsupported
defc STDIO_MSG_OPEN        = 7   ; enter: c = flags (???? ?CIOA) de = char *filename, exit: carry set = error, fd must not forward message
defc STDIO_MSG_CLOS        = 8   ; fd must not forward message
defc STDIO_MSG_ICTL        = 9   ; enter: de = request bc = arg, exit: hl = return value or carry set = error
defc STDIO_MSG_SYNC        = 10  ; transfer any buffered data to device, exit: carry set = error

defc STDIO_MSG_GROUP_1     = 11  ; high level FILE* (eg buffers) can likely ignore messages above

defc STDIO_MSG_FOPN        = 11  ; initialize high level buffer (fd-level should ignore, message should not be forwarded)
defc STDIO_MSG_FCLS        = 12  ; deallocate high level buffers (fd-level should ignore)
defc STDIO_MSG_FLSH        = 13  ; enter: c = STDIO_FLUSH_* (fd-level should ignore)

defc STDIO_MSG_GROUP_2     = 14  ; low level fd drivers must ignore messages above

; SOCKET MESSAGES

; FILESYSTEM MESSAGES

; message constants

defc STDIO_SEEK_SET        =  0  ; set file pointer to indicated absolute file position
defc STDIO_SEEK_END        =  1  ; set file pointer relative to end of file
defc STDIO_SEEK_CUR        =  2  ; set file pointer relative to current file position
defc STDIO_SEEK_REP        =  3  ; report current file position

defc STDIO_FLUSH_INBUF     =  0  ; flush high level input buffer
defc STDIO_FLUSH_OUTBUF    =  1  ; flush high level output buffer

; *************
; ERROR NUMBERS
; *************

defc ENONE   = 0
defc EACCES  = 1
defc EBADF   = 2
defc EDEVNF  = 3
defc EINVAL  = 4
defc ENFILE  = 5
defc ENOMEM  = 6

; *********************
; STDIO FILE STRUCTURES
; *********************
;
; The stdio chain consists of (optional) high level FILE*, high level buffers,
; low level dup fd, low level filter fds, low level device driver.  Messages
; are passed through this chain and terminate on a device driver where the
; service is ultimately performed.  Each step in a stdio chain is represented
; by a stdio data structure.  The various structures are documented below and
; are created by one of the open() calls and deallocated by one of the close() calls.
;
; Both device drivers and filter drivers can specify additional bytes be allocated
; and appended to the end of its file structure in order to hold state.  The number
; of extra bytes required must be specified in the word prior to the message
; interpretter address supplied. 

; FILE *
; high level i/o data structure
;
; offset   bytes   contents
;   +0       1     JP instruction (195)
;   +1/2     2     next file structure in stdio chain
;   +3       1     flags 0000 1IOU (FILE*, input, output, unget char)
;   +4       1     unget char

defc STDIO_SIZEOF_FILE = 5

; DEVICE DRIVER FD
; low level i/o data structure
;
; offset   bytes   contents
;   +0       1     CALL instruction (205)
;   +1/2     2     device driver message interpretter address
;   +3       1     flags 0000 0IOA (input, output, writes append)
;   +4       1     reference count
;   +5      any    additional bytes required by driver to hold state

defc STDIO_SIZEOF_FDSTRUCT = 5

; DUP FD
; low level i/o data structure
;
; offset   bytes   contents
;   +0       1     JP instruction (195)
;   +1/2     2     next file structure in stdio chain
;   +3       1     flags 1000 0IOA (dup, input, output, writes append)
;   +4       1     reference count = 1 (dup fds are never referenced more than once)

defc STDIO_SIZEOF_DUP = 5

; FILTER FD
; low level i/o data structure
;
; offset   bytes   contents
;   +0       1     CALL instruction (205)
;   +1/2     2     filter message interpretter address
;   +3       1     flags 0100 0IOA (filter, input, output, writes append)
;   +4       1     reference count
;   +5       1     JP instruction (195)
;   +6/7     2     next file structure in stdio chain
;   +8      any    additional bytes required by filter to hold state

defc STDIO_SIZEOF_FILTER = 8

; ****
; CRT0
; ****
;
; STDIO requires the following variables to be included in target startup code.
;
; * Table of Open FILEs (must appear contiguously)
;
; _stdin                           (2 bytes)
; _stdout                          (2 bytes)
; _stderr                          (2 bytes)
; _stdio_filetbl[STDIO_NUMFILE]    (STDIO_NUMFILE * 2 bytes)
;
; * Table of Open FDs
;
; _stdio_fdtbl[STDIO_NUMFD]        (STDIO_NUMFD * 2 bytes)
;
; * Table of Device Drivers
;
; _stdio_defdev                    (2 bytes, default device driver message interpretter address)
; _stdio_devtbl[]                  (each entry 3 bytes: letter identifier, message interpretter address)
; defb 0                           (terminates device table)
;
; * ERRNO
;
; _errno                           (2 bytes to hold error identifiers)
;
; * STDIO Heap
;
; _stdio_heap                      (4 byte heap pointer for malloc, can share the standard process heap)
;
; * High Level Scan Converters
;
; jumptbl_printf                   (list of output scan converters used by printf family)
; defb 0                           (terminates printf list)
; jumptbl_scanf                    (list of input scan converters used by scanf family)
; defb 0                           (terminates scanf list)
